---
title: "Southampton_PV_validation"
author: "Phil Wu: phil.wu@soton.ac.uk"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      #results = 'hide', 
                      error = FALSE, 
                      #include = FALSE, 
                      out.width="600px", 
                      dpi=120,
                      warning = FALSE,
                      message = FALSE,
                      fig_caption = TRUE,
                      fig_height = 4, # default, make it bigger to stretch vertical axis
                      fig_width = 6, # full width
                      fig.align = 'center', # full width
                      tidy = TRUE ) # tidy up code in case echo = TRUE
options(digits=3) 
# Set start time ----
startTime <- Sys.time() 

myPackages <- c("tidyverse", 
                "lubridate", 
                "zoo", 
                "xts", 
                "chron", 
                "data.table", 
                "scales",
                "DT",
                "fTrading", 
                "data.table", 
                "knitr", 
                "gridExtra", 
                "plotly", 
                "stringr", 
                "kableExtra", 
                "maptools" ,
                "ggmap",
                "ggplot2",
                "ggsn",
                "sf",
                "leaflet", 
                "fmsb", 
                "RColorBrewer",
                #"plyr", # this library clash with dplyr all the time. 
                "png")
#"sp" ,
#"rgdal",
#"raster", 
#"rasterVis" ,
#"rgeos")

#devtools::install_github("tidyverse/ggplot2")
library(dplyr)
required_packages <- function(x,y){
  for( i in x ){
    if( ! require( i , character.only = TRUE ) ){
      if( Sys.info()["sysname"] == "Linux" ){
        install.packages( i , repos=y , type="source" , quiet=TRUE , dependencies = TRUE , verbose = FALSE )
      } else {
        install.packages( i , repos=y , quiet=TRUE , dependencies = TRUE , verbose = FALSE )
      }
      require( i , character.only = TRUE, quietly = TRUE )
    }
  }
}

required_packages((myPackages),"http://cran.rstudio.com/")

# When find functions under dplyr (e.g. group_by) not working, try detach the packpage of "plyr"
#detach(package:plyr)

# Housekeeping
#rm(list=ls(all=TRUE)) # remove all objects from workspace

#Extended palette
palette_Dark2 <- colorRampPalette(brewer.pal(8, "Dark2"))
```


```{r, include = F}
## Overwrite the ggplot theme set to a more customerised appearance 
ggplot <- function(...) ggplot2::ggplot(...) + 
  scale_fill_brewer(palette = "Set1") + 
  scale_color_brewer(palette = "Set1") +
  theme_gray() +
  theme(aspect.ratio = 1,
        panel.background= element_rect(colour = "grey70", fill = "grey95"),
        panel.border = element_rect(colour = "grey70", fill = NA),
        strip.background = element_rect(colour = "grey70"))
```

1. randomly select a number of areas in Southampton
2. find out buildings in selected areas with pv - using satellite images
3. run model on these areas and see if these buildings were identified as suitable 
4. discuss if conflict is found 

```{r}
# import uk grid of 1km x 1km
uk_grid <- sf::st_read("./data/1km_grid_region.shp" , quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) 

# import southampton border shp
soton_border <- sf::st_read("./data/Southampton_border.shp" , quiet = TRUE) %>% 
  st_transform(4326) # original crs is meter, so convert to degree 

# Check extent (optional)
#raster::extent(soton_border)

# Crop uk grid using southampton border 
soton_grid <- uk_grid[soton_border,] 

# Check how much cells are in Southampton border
#nrow(soton_grid)

# The resolution of grid, 1km x 1km, is too big for this work 
# The grid is therefore resampled to a smaller size
# The function to use is 'disaggregate
# But before that the grid shp (sf) needs to be converted into raster

# Convert sf dataframe into a raster object using 'raster'. 
# This will be the base raster layer including cell size, crs, etc
raster_base <- raster::raster(as(soton_grid, "Spatial")) %>% 
  disaggregate(fact = 4) # resize by a factor of 4

ncell(raster_base)
nrow(raster_base)

# Then overlay any shp with base raster layer, and extract values
# in this case, the fraction of coverage is extracted using 'getCover' 
soton_grid_resize <- raster::rasterize(as(soton_border, "Spatial"), 
                                            raster_base, 
                                            getCover = T) %>% # show  fraction of each cell covered 
  #disaggregate(fact = 4) %>%  # resample can be made at any point
  raster::rasterToPolygons() %>%  # convert back to polygon
  st_as_sf() %>%  # result is a st object, then change to sf
  #.[soton_border, ] %>% 
  dplyr::filter(layer == 1)  # for some versions, this value should be changed to 100


# check total number of cells
#nrow(soton_grid_resample)

# Plot the cells on satellite image and see if the resolution is satisfactory
leaflet(width = "70%", height = 400) %>%  
  # below: resolution fixed to avoid mouse accidentially draging map around
  addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_grid_resize, weight = 1, fillOpacity = 0) %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) 

```


Then a number of cells are to be randomly selected, and eyeball check to find out buildings with pv on roof. 

```{r}
set.seed(26)
grid_sample <- soton_grid_resize %>% 
  mutate(ID = rownames(.)) %>% 
  sample_n(10) 

grid_sample$ID

leaflet(width = "70%") %>% 
  addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addPolygons(data = grid_sample, 
              weight = 2, color = "red", 
              opacity = 1 , 
              fillColor = "red" , fillOpacity = 0 , 
              popup = paste("ID: ", grid_sample$ID)) 
#class(grid_sample)  
#head(grid_sample)
#st_write(grid_sample, "./data/grid_sample2.shp",  layer_options = "GEOMETRY=AS_XY")
```


```{r}
area <- (117111  - 116882 )* ( 441973  - 441671 )
area
```

## Identify buildings with PV 

```{r}

gaze <- sf::st_read("../GIS/Southampton/GAZETTEER_PROPERTIES_point.shp", quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)    # convert CRS to wgs84 (from meter to degree) 

#nrow(gaze)

gaze_crop <- gaze[grid_sample,]

#nrow(gaze_crop)
#head(gaze_crop)
#head(gaze)

leaflet(width = "70%") %>% 
  addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  #addTiles() %>% 
  addPolygons(data = grid_sample, weight = 2, 
              color = "red", opacity = 1 , 
              fillColor = "red" , fillOpacity = 0.0, 
              popup = ~ID) %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addCircleMarkers(data = gaze_crop ,  popup = paste(gaze_crop$TYPE,": ",gaze_crop$NAMEPRI, as.character(gaze_crop$UPRN)) , radius = 0.5 )

```

```{r}

pv_building <- read.csv("./PV_buildings.csv", header = T, sep = "," , stringsAsFactors = F )

#head(pv_building)
#head(gaze_crop)

gaze_pv <- gaze_crop %>%
  right_join(pv_building, by = c("UPRN" = "UPRN_ID")) 
  
leaflet(width = "80%" , height = 500) %>% 
  addProviderTiles(provider = providers$Esri.WorldImagery) %>% 
  addPolygons(data = soton_border, color = "black", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addPolygons(data = grid_sample , color = "red", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addCircleMarkers(data = gaze_pv, radius = 2 , 
                   fillOpacity = 1, fillColor = "blue", 
                   popup = paste(gaze_pv$TYPE,": ",gaze_pv$NAMEPRI, as.character(gaze_pv$UPRN))  )
```


```{r}

gis_roof <- sf::st_read("./data/Applicable_roof_area.shp", quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)    # convert CRS to wgs84 (from meter to degree) 

gis_roof_subset <- gis_roof[grid_sample,]


leaflet(width="80%") %>% 
  addProviderTiles(provider = providers$Esri.WorldImagery) %>% 
  #addTiles() %>% 
  addPolygons(data = gis_roof_subset , weight = 5, color = "red", fillColor = "red", fillOpacity = 0.5 ) %>% 
  addCircleMarkers(data = gaze_pv, radius = 5 , 
                   fillOpacity = 1, fillColor = "blue", 
                   popup = paste(gaze_pv$TYPE,": ",gaze_pv$NAMEPRI, as.character(gaze_pv$UPRN))  )


```

Patrick's comments: 
1) 3 of 10 sample randomly selected areas are industrial and have no PV at the moment
2) This result does not help the validation, and so no need to mention them
3) It is better to target residential areas and gain greater sample size 
4) Commercial buildings have larger roofs with higher PV potential, but their feasibility needs more rigorous assessment, so can be excluded from the scope of this work
5) New built houses have PV regardless of their feasibility, and they can also be eliminated from sample. 

# Re-select sample areas from residential areas, and eyeball existing PV. 

```{r}
# create a subset of gazetteer for residential properties only
gaze_residential <- gaze %>% 
  #head()
  filter(str_detect(TYPE, "Residential"))

# Find out how many gazetteer points are in each grid cell 
soton_grid_residential <- soton_grid_resize %>%
  mutate(ID = seq.int(n())) %>% 
  st_join(gaze_residential, join = st_intersects) %>% # st_join creates a large number of pairs 
  filter(!is.na(POSTCODE)) %>%  # filter out empty joins
  #head()
  group_by(ID) %>% 
  summarise(Count = n() ) %>%  
  ungroup

leaflet(width="70%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addPolygons(data=soton_border, fillOpacity = 0, weight = 2, color = "blue") %>% 
  addPolygons(data = soton_grid_resize, fillOpacity = 0, 
              weight = 1, color="black") %>% 
  addScaleBar()
```
```{r}

st_area(st_transform(soton_grid_resize[1,], 27700))
st_bbox(st_transform(soton_grid_resize[1,], 27700)) %>%
  as.numeric() %>% 
  unlist() %>% 
  matrix(nrow = 1, byrow = T) %>% 
  as.data.frame() %>% 
  setNames(c("xmin", "ymin", "xmax", "ymax")) %>% 
  mutate(x = xmax - xmin, y= ymax - ymin)
```

## Preparation for Sample Selection
### histogram of property density across city

```{r}

# use distribution a histogram 
median_soton_grid_res <- median(soton_grid_residential$Count)
median_density <- round(median_soton_grid_res/67868*1000,1)

#min(soton_grid_residential$Count)

#library(scales)
ggplot(soton_grid_residential ) + 
  #geom_bar(aes(x=Count, y=..prop..) , stat = "count")+
  geom_histogram(aes(x=Count),stat = "bin" , bins = 30 , colour = "black")+
  geom_vline(xintercept = median_soton_grid_res, colour = "red")+
  geom_text(aes(x=median_soton_grid_res +150 , 
                y=130, label = paste("median:", median_soton_grid_res)  ) , 
            nudge_x = 10 , 
            color ="red" , 
            fontface='plain') + 
  labs(x = "Number of properties in each block" ,  y="Blocks having various number of properties")+
  #scale_y_continuous(labels = function(x) paste(round(x,2 ), "%")) +
  scale_x_continuous( breaks = seq(0,1000, 100) )
  #ylim(0,150)

```

### Map: distribution of property density

```{r}
# Show the distribution on map 
bins_property_density <- quantile(soton_grid_residential$Count, seq(from = 0.1, to =1, by=0.2))
pal_property_density <- colorBin("YlOrRd", domain = soton_grid_residential$Count, 
                bins = bins_property_density ,  na.color = "#ffffff00")

soton_grid_residential%>% 
  filter(Count > 0) %>% 
  leaflet(width = "80%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addPolygons(data =  soton_border , weight = 2,
              fillOpacity = 0) %>% 
  addPolygons(fillColor = ~pal_property_density(Count), 
              weight = 1, color="black" , 
              fillOpacity = 1 , 
              label = ~as.character(Count)) %>% 
  addLegend("bottomright", 
            pal=pal_property_density, 
            values = ~Count, 
            title = "Property count" , 
            opacity = 1 , na.label = "empty") %>% 
  addScaleBar() 


```
Below is just to find how to create a list of sample using seeds

```{r}
temp <- soton_grid_residential %>% 
  filter(Count >0) 

allID <- data.frame(ID = temp$ID)

sampleID_all <- data.frame(Seed = as.integer(), 
                           AreaID = as.integer())

for (i in seq(1:100)){
  set.seed(i)
  randID <- sample_n(allID, 10) %>% 
    mutate(Seed = i, ID = ID)
  sampleID_all <- rbind(sampleID_all, randID)
  #print(sampleID_all)
}

sampleID_all %>% 
  filter(ID == 13) 
  
```


```{r}
# The code below is to find out which seed would have Area No.13 included, 
# which is upper bassett, a residential area with large number of PV

head(allID)
tempfuc <- function(x){
  set.seed(x)
  randid2 <- sample_n(allID, 10) %>% 
    mutate(Seed = x, ID = ID)
  return(randid2)
}

testsampleid <- lapply(seq(1:100) , tempfuc) %>% 
  bind_rows() %>% 
  filter(ID == 13)

head(testsampleid)
```
## Sample selection

```{r}
set.seed(89) 
soton_grid_residential %>% 
  filter(Count > 0) %>% 
  sample_n(10) %>% 
  leaflet(width = "70%") %>% 
  addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addPolygons(weight = 2, color = "red", 
              opacity = 1 , fillColor = "red" , fillOpacity = 0 , 
              label = ~paste("ID: ", ID), 
              labelOptions = labelOptions(noHide = T))

```

### Map: property density VS sample selection

```{r}

set.seed(89) 
soton_grid_residential %>% 
  filter(Count > 0) %>% 
  sample_n(10) ->soton_grid_sample

soton_grid_residential_only <- soton_grid_residential%>% 
  filter(Count > 0) 

  
soton_grid_residential_only %>% 
  leaflet(width = "80%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addPolygons(data =  soton_border , weight = 2,
              fillOpacity = 0) %>% 
  addPolygons(fillColor = ~pal_property_density(Count), 
              weight = 0, color="black" , 
              fillOpacity = 1 , 
              label = ~as.character(Count)) %>% 
  addPolygons(data = soton_grid_resize, 
              fillOpacity = 0, 
              weight = 1, color = "black") %>% 
  addPolygons(data = soton_grid_sample, fillOpacity = 0, 
              color = "blue" , opacity = 1) %>% 
  addLegend("bottomright",  data = soton_grid_sample, colors = "blue", opacity = 0, labels = "Sample area" ) %>% 
  addLegend("bottomright", 
            pal=pal_property_density, 
            values = ~Count, 
            title = "Property count" , 
            opacity = 1) %>%   
  addScaleBar() 
```




```{r}
# randomly select 10 areas among those cells with at least 1 residential property
# use seed 89 as it includes Upper bassett where a large number of PV are found
set.seed(89)
grid_sample_residential <- soton_grid_residential %>% 
  filter(Count > 0) %>% 
  sample_n(10) 

head(grid_sample_residential,10)

# subset gazetteer data for only those in sample areas
gaze_crop_residential <- gaze[grid_sample_residential,]
```

```{r}
nrow(gaze_crop_residential)
```


The sample points are then exported to KML, and imported to google earth to eyeball existing pv

Google earth's imagery date: 5/26/2017 

```{r}
#st_write(gaze_crop_residential, "./data/test89.kml")

# Also exported 10 sample areas. 
#st_write(grid_sample_residential, "grid_test.kml")
```

```{r}
head(grid_sample)
```


All the selected buildings were eyeballed using Google earth, and the results are imported backed to R.

```{r}
existingPV_soton <- sf::st_read("./data/existing_PV_in_southampton_10_sample_areas.kml" , quiet = TRUE) 

#st_write(grid_sample_residential , "./data/grid_sample_new.shp", layer_options = "GEOMETRY=AS_XY" )

```

### Map: actual PV

```{r}
# map showing all existing PVs together with the 10 sample areas
leaflet(width="80%") %>% 
  #addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addTiles(options = providerTileOptions(maxZoom = 100)) %>% 
  addPolygons(data = grid_sample_residential, color = "red", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addCircleMarkers(data=existingPV_soton, radius = 1, fillOpacity = 1, stroke = 1, 
                   popup = ~ADDRESS )
```


### 1. Map: model estimates
In this section, the building unit used is changed to individual properties instead of buildings. 

```{r}
# sra - Suitable Roof Area
# Attempt 1: slope STD=10, aspect STD=10, AreaSol=10

sra_sample <- sf::st_read("./data/SRA_10_10_600.shp", quiet = T) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700) 
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) 

soton_property_grid <- sf::st_read("./data/Area_building_grid.shp", quiet = T) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)   
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) 

leaflet(width="80%", height = "400") %>% 
#  addTiles() %>% 
  addProviderTiles(providers$Esri.WorldImagery,options = providerTileOptions(maxZoom = 100)) %>% 
  #addPolygons(data = grid_sample_residential) %>% 
  addMarkers(data = existingPV_soton, 
#                   fillOpacity = 1, fillColor = "red", stroke = 1, color = "red", 
                   popup = ~ADDRESS ) %>% 
  addPolygons(data = soton_property_grid , fillOpacity = 0, 
              color = "black", stroke = 0.2 , opacity = 1, popup = ~as.character(OBJECTID))  %>% 
  addPolygons(data = sra_sample , fillOpacity = 0, 
              color = "blue", stroke = 1 )


```

### 2: Map: combine building polygons with actual PV. 
Used property outlines instead

```{r}
# merge existing PV (points) with building outlines (polygons)
property_w_PV <- soton_property_grid %>% 
  st_join(existingPV_soton, join= st_intersects ) %>% 
  filter(!is.na(POSTCODE)) %>%  # remove bld that don't have points in them
  #head()
  group_by(OBJECTID) %>% 
  summarise(Count = n()  ) %>%
  filter(Count > 0) %>%  # 
  ungroup()  %>%
  mutate(BID = OBJECTID, NPV = Count) %>%
  dplyr::select(-OBJECTID, -Count)
  


leaflet(width="70%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 100)) %>% 
  addMarkers(data = existingPV_soton, 
#                   fillOpacity = 1, fillColor = "red", stroke = 1, color = "red", 
                   popup = ~ADDRESS ) %>% 
  addPolygons(data = property_w_PV, 
              color="black" , stroke = 1, opacity = 1, 
              popup = ~as.character(BID)) %>% 
  addPolygons(data = sra_sample , fillOpacity = 0, 
              color = "blue", stroke = 1 , popup = ~as.character(Id) )


```

### 2. See overlap of buildings-PV and GIS estimates.

```{r}
property_w_PV %>% 
  #head()
  st_join(sra_sample ,  join = st_intersects) %>% 
  #filter(BID == 53951) 
  #filter(!is.na(Id)) %>% 
  #nrow()
  #head()
  group_by(BID, NPV) %>% 
  summarise(NGIS = sum(!is.na(Id)), AGIS = sum(Shape_Area)) %>% 
  #filter(BID == 53951) %>% 
  #head()
  ungroup() -> property_pv_gis

head(property_pv_gis)
```

```{r}
summary(property_pv_gis)

nrow(property_pv_gis)

```




### Actual PV versus model estimates

```{r}
leaflet(width="75%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 120)) %>% 
  addMarkers(data = existingPV_soton, 
#                   fillOpacity = 1, fillColor = "red", stroke = 1, color = "red", 
                   popup = ~ADDRESS ) %>% 
  addPolygons(data = property_w_PV, 
              color="black" , stroke = 1, opacity = 1, 
              popup = ~as.character(BID)) %>% 
  addPolygons(data = sra_sample , fillOpacity = 0, 
              color = "blue", stroke = 1 , popup = ~as.character(Id) ) %>% 
  addPolygons(data = property_pv_gis , fillOpacity = 0, 
              color = "green", stroke = 1 , popup = ~as.character(paste("<b>BID:</b> ", BID, "<br/>", 
                                                                        "<b>NPV: </b>", NPV , "<br/>",
                                                                        "<b>NGIS:</b>",NGIS , "<br/>" ) ))

```

```{r}
head(property_pv_gis)

property_pv_gis %>% 
  #nrow()
  #arrange(NPV, NGIS) %>% 
  arrange(desc(NPV), desc(AGIS)) %>% 
  head()
```


# SRA density 

1. convert sra to points and count number of points 

```{r}
sra_soton <- sf::st_read("../GIS/Southampton/sra_10_10_600_soton.shp", quiet = T) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700) 
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) 

sra_soton_point <- sra_soton %>% 
  st_centroid()

head(sra_soton_point)
leaflet() %>% 
  addPolygons(data = soton_grid_resize) %>% 
  addMarkers(data = sra_soton_point)
```






































