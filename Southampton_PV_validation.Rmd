---
title: "Southampton_PV_validation"
author: "Phil Wu: phil.wu@soton.ac.uk"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      #results = 'hide', 
                      error = FALSE, 
                      #include = FALSE, 
                      out.width="600px", 
                      dpi=120,
                      warning = FALSE,
                      message = FALSE,
                      fig_caption = TRUE,
                      fig_height = 4, # default, make it bigger to stretch vertical axis
                      fig_width = 6, # full width
                      fig.align = 'center', # full width
                      tidy = TRUE ) # tidy up code in case echo = TRUE
options(digits=3) 
# Set start time ----
startTime <- Sys.time() 

myPackages <- c("tidyverse", 
                "lubridate", 
                "zoo", 
                "xts", 
                "chron", 
                "data.table", 
                "scales",
                "DT",
                "fTrading", 
                "data.table", 
                "knitr", 
                "gridExtra", 
                "plotly", 
                "stringr", 
                "kableExtra", 
                "maptools" ,
                "ggmap",
                "ggplot2",
                "ggsn",
                "sf",
                "leaflet", 
                "fmsb", 
                "RColorBrewer",
                #"plyr", # this library clash with dplyr all the time. 
                "png")
#"sp" ,
#"rgdal",
#"raster", 
#"rasterVis" ,
#"rgeos")

#devtools::install_github("tidyverse/ggplot2")

required_packages <- function(x,y){
  for( i in x ){
    if( ! require( i , character.only = TRUE ) ){
      if( Sys.info()["sysname"] == "Linux" ){
        install.packages( i , repos=y , type="source" , quiet=TRUE , dependencies = TRUE , verbose = FALSE )
      } else {
        install.packages( i , repos=y , quiet=TRUE , dependencies = TRUE , verbose = FALSE )
      }
      require( i , character.only = TRUE, quietly = TRUE )
    }
  }
}

required_packages((myPackages),"http://cran.rstudio.com/")

# When find functions under dplyr (e.g. group_by) not working, try detach the packpage of "plyr"
#detach(package:plyr)

# Housekeeping
#rm(list=ls(all=TRUE)) # remove all objects from workspace

#Extended palette
palette_Dark2 <- colorRampPalette(brewer.pal(8, "Dark2"))
```


```{r, include = F}
# Overwrite the ggplot theme set to a more customerised appearance 
#ggplot <- function(...) ggplot2::ggplot(...) + 
#  scale_fill_brewer(palette = "Set1") + 
#  scale_color_brewer(palette = "Set1") +
#  theme_gray() +
#  theme(aspect.ratio = 1,
#        panel.background= element_rect(colour = "grey70", fill = "grey95"),
#        panel.border = element_rect(colour = "grey70", fill = NA),
#        strip.background = element_rect(colour = "grey70"))
```

1. randomly select a number of areas in Southampton
2. find out buildings in selected areas with pv - using satellite images
3. run model on these areas and see if these buildings were identified as suitable 
4. discuss if conflict is found 

```{r}
# import uk grid of 1km x 1km
uk_grid <- sf::st_read("./data/1km_grid_region.shp" , quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) 

# import southampton border shp
soton_border <- sf::st_read("./data/Southampton_border.shp" , quiet = TRUE) %>% 
  st_transform(4326) # original crs is meter, so convert to degree 

# Check extent (optional)
#raster::extent(soton_border)

# Crop uk grid using southampton border 
soton_grid <- uk_grid[soton_border,] 

# Check how much cells are in Southampton border
#nrow(soton_grid)

# The resolution of grid, 1km x 1km, is too big for this work 
# The grid is therefore resampled to a smaller size
# The function to use is 'disaggregate
# But before that the grid shp (sf) needs to be converted into raster

# Convert sf dataframe into a raster object using 'raster'. 
# This will be the base raster layer including cell size, crs, etc
raster_base <- raster::raster(as(soton_grid, "Spatial")) %>% 
  disaggregate(fact = 4) # resize by a factor of 4

# Then overlay any shp with base raster layer, and extract values
# in this case, the fraction of coverage is extracted using 'getCover' 
soton_grid_resize <- raster::rasterize(as(soton_border, "Spatial"), 
                                            raster_base, 
                                            getCover = T) %>% # show  fraction of each cell covered 
  #disaggregate(fact = 4) %>%  # resample can be made at any point
  raster::rasterToPolygons() %>%  # convert back to polygon
  st_as_sf() %>%  # result is a st object, then change to sf
  #.[soton_border, ] %>% 
  filter(layer == 100)  

# check total number of cells
#nrow(soton_grid_resample)

# Plot the cells on satellite image and see if the resolution is satisfactory
leaflet(width = "80%", height = 500) %>% 
  addProviderTiles(providers$Esri.WorldImagery) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_grid_resize, weight = 1, fillOpacity = 0) %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) 

```

Then a number of cells are to be randomly selected, and eyeball check to find out buildings with pv on roof. 

```{r}
set.seed(26)
grid_sample <- soton_grid_resize %>% 
  mutate(ID = rownames(.)) %>% 
  sample_n(10) 

grid_sample$ID

leaflet(width = "60%") %>% 
  addProviderTiles(providers$Esri.WorldImagery) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addPolygons(data = grid_sample, 
              weight = 2, color = "red", 
              opacity = 1 , 
              fillColor = "red" , fillOpacity = 0 , 
              popup = paste("ID: ", grid_sample$ID)) 
  
#st_write(grid_sample, "./data/grid_sample.shp",  layer_options = "GEOMETRY=AS_XY")
```

Identify buildings with PV 

```{r}

gaze <- sf::st_read("../GIS/Southampton/GAZETTEER_PROPERTIES_point.shp", quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)    # convert CRS to wgs84 (from meter to degree) 

#nrow(gaze)

gaze_crop <- gaze[grid_sample,]

#nrow(gaze_crop)
#head(gaze_crop)
#head(gaze)

leaflet(width = "80%", height = 800) %>% 
  addProviderTiles(providers$Esri.WorldImagery) %>% 
  #addTiles() %>% 
  addPolygons(data = grid_sample, weight = 2, 
              color = "red", opacity = 1 , 
              fillColor = "red" , fillOpacity = 0.0, 
              popup = ~ID) %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addCircleMarkers(data = gaze_crop ,  popup = paste(gaze_crop$TYPE,": ",gaze_crop$NAMEPRI, as.character(gaze_crop$UPRN)) , radius = 0.5 )

```

```{r}

pv_building <- read.csv("./PV_buildings.csv", header = T, sep = "," , stringsAsFactors = F )

#head(pv_building)
#head(gaze_crop)

gaze_pv <- gaze_crop %>%
  right_join(pv_building, by = c("UPRN" = "UPRN_ID")) 
  
leaflet(width = "80%" , height = 500) %>% 
  addProviderTiles(provider = providers$Esri.WorldImagery) %>% 
  addPolygons(data = soton_border, color = "black", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addPolygons(data = grid_sample , color = "red", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addCircleMarkers(data = gaze_pv, radius = 2 , 
                   fillOpacity = 1, fillColor = "blue", 
                   popup = paste(gaze_pv$TYPE,": ",gaze_pv$NAMEPRI, as.character(gaze_pv$UPRN))  )
```


```{r}

gis_roof <- sf::st_read("./data/Applicable_roof_area.shp", quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)    # convert CRS to wgs84 (from meter to degree) 

gis_roof_subset <- gis_roof[grid_sample,]


leaflet(width="80%") %>% 
  addProviderTiles(provider = providers$Esri.WorldImagery) %>% 
  #addTiles() %>% 
  addPolygons(data = gis_roof_subset , weight = 5, color = "red", fillColor = "red", fillOpacity = 0.5 ) %>% 
  addCircleMarkers(data = gaze_pv, radius = 5 , 
                   fillOpacity = 1, fillColor = "blue", 
                   popup = paste(gaze_pv$TYPE,": ",gaze_pv$NAMEPRI, as.character(gaze_pv$UPRN))  )


```





Patrick's comments: 
1) 3 of 10 sample randomly selected areas are industrial and have no PV at the moment
2) This result does not help the validation, and so no need to mention them
3) It is better to target residential areas and gain greater sample size 
4) Commercial buildings have larger roofs with higher PV potential, but their feasibility needs more rigorous assessment, so can be excluded from the scope of this work
5) New built houses have PV regardless of their feasibility, and they can also be eliminated from sample. 

# Re-select sample areas from residential areas, and eyeball existing PV. 

```{r}
# create a subset of gazetteer for residential properties only
gaze_residential <- gaze %>% 
  #head()
  filter(str_detect(TYPE, "Residential"))

# Find out how many gazetteer points are in each grid cell 
soton_grid_residential <- soton_grid_resize %>%
  mutate(ID = seq.int(n())) %>% 
  st_join(gaze_residential, join = st_intersects) %>% # st_join creates a large number of pairs 
  group_by(ID) %>% 
  summarise(Count = n() - 1) %>%  # empty pair also returns as a row, hence "-1"
  ungroup

# use distribution a histogram 
median_soton_grid_res <- median(soton_grid_residential$Count)

ggplot(soton_grid_residential ) + 
  geom_histogram(aes(x=Count),stat = "bin" , binwidth = 40 , colour = "black")+
  geom_vline(xintercept = median_soton_grid_res, colour = "red")+
  geom_text(aes(x=median_soton_grid_res , 
                y=120, 
                label = median_soton_grid_res ), 
            nudge_x = 30 , 
            color ="red" )

```



```{r}
# Show the distribution on map 
bins <- quantile(soton_grid_residential$Count, seq(from = 0.1, to =1, by=0.1))
pal <- colorBin("YlOrRd", domain = soton_grid_residential$Count, bins = bins ,  na.color = "")

soton_grid_residential%>% 
  filter(Count > 0) %>% 
  leaflet(width = "80%") %>% 
  addTiles() %>% 
  addPolygons(data =  soton_border , weight = 2,
              fillOpacity = 0) %>% 
  addPolygons(fillColor = ~pal(Count), 
              weight = 0, 
              fillOpacity = 1 , 
              label = ~as.character(Count)) 

```

```{r}

temp <- soton_grid_residential %>% 
  filter(Count >0) 

allID <- data.frame(ID = temp$ID)

sampleID_all <- data.frame(Seed = as.integer(), 
                           AreaID = as.integer())

for (i in seq(1:100)){
  set.seed(i)
  randID <- sample_n(allID, 10) %>% 
    mutate(Seed = i, ID = ID)
  sampleID_all <- rbind(sampleID_all, randID)
  #print(sampleID_all)
}

sampleID_all %>% 
  filter(ID == 13) 
  
```



```{r}
# The code below is to find out which seed would have Area No.13 included, 
# which is upper bassett, a residential area with large number of PV

set.seed(89) 
soton_grid_residential %>% 
  filter(Count > 0) %>% 
  sample_n(10) %>% 
  leaflet(width = "100%", height="800") %>% 
  addProviderTiles(providers$Esri.WorldImagery) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addPolygons(weight = 2, color = "red", 
              opacity = 1 , fillColor = "red" , fillOpacity = 0 , 
              label = ~paste("ID: ", ID), 
              labelOptions = labelOptions(noHide = T))

```


```{r}
# randomly select 10 areas among those cells with at least 1 residential property
# use seed 89 as it includes Upper bassett where a large number of PV are found
set.seed(89)
grid_sample_residential <- soton_grid_residential %>% 
  filter(Count > 0) %>% 
  sample_n(10) 

head(grid_sample_residential,10)

# subset gazetteer data for only those in sample areas
gaze_crop_residential <- gaze[grid_sample_residential,]
```


The sample points are then exported to KML, and imported to google earth to eyeball existing pv

Google earth's imagery date: 5/26/2017 

```{r}
#st_write(gaze_crop_residential, "./data/test89.kml")

# Also exported 10 sample areas. 
#st_write(grid_sample_residential, "grid_test.kml")
```

All the selected buildings were eyeballed using Google earth, and the results are imported backed to R.

```{r}
existingPV_soton <- sf::st_read("./data/existing_PV_in_southampton_10_sample_areas.kml" , quiet = TRUE) 

head(existingPV_soton)

```


```{r}

leaflet(width="60%") %>% 
  addTiles() %>% 
  addPolygons(data = grid_sample_residential, color = "red", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addCircleMarkers(data=existingPV_soton, radius = 1, fillOpacity = 0, stroke = 1, 
                   popup = ~ADDRESS )
```

```{r}
bins <- quantile(soton_grid_residential$Count, seq(from = 0.1, to =1, by=0.1))
pal <- colorBin("YlOrRd", domain = soton_grid_residential$Count, bins = bins ,  na.color = "")

grid_sample_residential%>% 
  st_join(existingPV_soton, join = st_intersects)  %>% 
  group_by(ID) %>% 
  summarise(Existing_PV = n() - 1) %>% 
  ungroup() %>% 
  head()
  leaflet() %>% 
  addPolygons()
  



```

soton_grid_residential <- soton_grid_resize %>%
  mutate(ID = seq.int(n())) %>% 
  st_join(gaze_residential, join = st_intersects) %>% # st_join creates a large number of pairs 
  group_by(ID) %>% 
  summarise(Count = n() - 1) %>%  # empty pair also returns as a row, hence "-1"
  ungroup






















