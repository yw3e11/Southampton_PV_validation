---
title: "Southampton_PV_validation"
author: "Phil Wu: phil.wu@soton.ac.uk"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      #results = 'hide', 
                      error = FALSE, 
                      #include = FALSE, 
                      out.width="600px", 
                      dpi=120,
                      warning = FALSE,
                      message = FALSE,
                      fig_caption = TRUE,
                      fig_height = 4, # default, make it bigger to stretch vertical axis
                      fig_width = 6, # full width
                      fig.align = 'center', # full width
                      tidy = TRUE ) # tidy up code in case echo = TRUE
options(digits=3) 
# Set start time ----
startTime <- Sys.time() 

myPackages <- c("tidyverse", 
                "lubridate", 
                "zoo", 
                "xts", 
                "chron", 
                "data.table", 
                "scales",
                "DT",
                "fTrading", 
                "data.table", 
                "knitr", 
                "gridExtra", 
                "plotly", 
                "stringr", 
                "kableExtra", 
                "maptools" ,
                "ggmap",
                "ggplot2",
                "ggsn",
                "sf",
                "leaflet", 
                "fmsb", 
                "RColorBrewer",
                #"plyr", # this library clash with dplyr all the time. 
                "png")
#"sp" ,
#"rgdal",
#"raster", 
#"rasterVis" ,
#"rgeos")

#devtools::install_github("tidyverse/ggplot2")
library(dplyr)
required_packages <- function(x,y){
  for( i in x ){
    if( ! require( i , character.only = TRUE ) ){
      if( Sys.info()["sysname"] == "Linux" ){
        install.packages( i , repos=y , type="source" , quiet=TRUE , dependencies = TRUE , verbose = FALSE )
      } else {
        install.packages( i , repos=y , quiet=TRUE , dependencies = TRUE , verbose = FALSE )
      }
      require( i , character.only = TRUE, quietly = TRUE )
    }
  }
}

required_packages((myPackages),"http://cran.rstudio.com/")

# When find functions under dplyr (e.g. group_by) not working, try detach the packpage of "plyr"
#detach(package:plyr)

# Housekeeping
#rm(list=ls(all=TRUE)) # remove all objects from workspace

#Extended palette
palette_Dark2 <- colorRampPalette(brewer.pal(8, "Dark2"))
```


```{r, include = F}
## Overwrite the ggplot theme set to a more customerised appearance 
ggplot <- function(...) ggplot2::ggplot(...) + 
  scale_fill_brewer(palette = "Set1") + 
  scale_color_brewer(palette = "Set1") +
  theme_gray() +
  theme(aspect.ratio = 1,
        panel.background= element_rect(colour = "grey70", fill = "grey95"),
        panel.border = element_rect(colour = "grey70", fill = NA),
        strip.background = element_rect(colour = "grey70"))
```

1. randomly select a number of areas in Southampton
2. find out buildings in selected areas with pv - using satellite images
3. run model on these areas and see if these buildings were identified as suitable 
4. discuss if conflict is found 

```{r}
# import uk grid of 1km x 1km
uk_grid <- sf::st_read("./data/1km_grid_region.shp" , quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) 

# import southampton border shp
soton_border <- sf::st_read("./data/Southampton_border.shp" , quiet = TRUE) %>% 
  st_transform(4326) # original crs is meter, so convert to degree 

# Check extent (optional)
#raster::extent(soton_border)

# Crop uk grid using southampton border 
soton_grid <- uk_grid[soton_border,] 

# Check how much cells are in Southampton border
#nrow(soton_grid)

# The resolution of grid, 1km x 1km, is too big for this work 
# The grid is therefore resampled to a smaller size
# The function to use is 'disaggregate
# But before that the grid shp (sf) needs to be converted into raster

# Convert sf dataframe into a raster object using 'raster'. 
# This will be the base raster layer including cell size, crs, etc
raster_base <- raster::raster(as(soton_grid, "Spatial")) %>% 
  disaggregate(fact = 4) # resize by a factor of 4

#ncell(raster_base)
#nrow(raster_base)

# Then overlay any shp with base raster layer, and extract values
# in this case, the fraction of coverage is extracted using 'getCover' 
soton_grid_resize <- raster::rasterize(as(soton_border, "Spatial"), 
                                            raster_base, 
                                            getCover = T) %>% # show  fraction of each cell covered 
  #disaggregate(fact = 4) %>%  # resample can be made at any point
  raster::rasterToPolygons() %>%  # convert back to polygon
  st_as_sf() %>%  # result is a st object, then change to sf
  #.[soton_border, ] %>% 
  dplyr::filter(layer == 1)  # for some versions, this value should be changed to 100


# check total number of cells
#nrow(soton_grid_resample)

# Plot the cells on satellite image and see if the resolution is satisfactory
leaflet(width = "70%", height = 400) %>%  
  # below: resolution fixed to avoid mouse accidentially draging map around
  addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_grid_resize, weight = 1, fillOpacity = 0) %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) 

```


Then a number of cells are to be randomly selected, and eyeball check to find out buildings with pv on roof. 

```{r}
set.seed(26)
grid_sample <- soton_grid_resize %>% 
  mutate(ID = rownames(.)) %>% 
  sample_n(10) 

grid_sample$ID

leaflet(width = "70%") %>% 
  addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  #addTiles() %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addPolygons(data = grid_sample, 
              weight = 2, color = "red", 
              opacity = 1 , 
              fillColor = "red" , fillOpacity = 0 , 
              popup = paste("ID: ", grid_sample$ID)) 
#class(grid_sample)  
#head(grid_sample)
#st_write(grid_sample, "./data/grid_sample2.shp",  layer_options = "GEOMETRY=AS_XY")
```


```{r}
area <- (117111  - 116882 )* ( 441973  - 441671 )
area
```

## Identify buildings with PV 

```{r}

gaze <- sf::st_read("../GIS/Southampton/GAZETTEER_PROPERTIES_point.shp", quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)    # convert CRS to wgs84 (from meter to degree) 

#nrow(gaze)

gaze_crop <- gaze[grid_sample,]

#nrow(gaze_crop)
#head(gaze_crop)
#head(gaze)

leaflet(width = "70%") %>% 
  addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  #addTiles() %>% 
  addPolygons(data = grid_sample, weight = 2, 
              color = "red", opacity = 1 , 
              fillColor = "red" , fillOpacity = 0.0, 
              popup = ~ID) %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addCircleMarkers(data = gaze_crop ,  popup = paste(gaze_crop$TYPE,": ",gaze_crop$NAMEPRI, as.character(gaze_crop$UPRN)) , radius = 0.5 )

```

```{r}

pv_building <- read.csv("./PV_buildings.csv", header = T, sep = "," , stringsAsFactors = F )

#head(pv_building)
#head(gaze_crop)

gaze_pv <- gaze_crop %>%
  right_join(pv_building, by = c("UPRN" = "UPRN_ID")) 
  
leaflet(width = "80%" , height = 500) %>% 
  addProviderTiles(provider = providers$Esri.WorldImagery) %>% 
  addPolygons(data = soton_border, color = "black", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addPolygons(data = grid_sample , color = "red", weight = 2, opacity = 1, fillOpacity = 0) %>% 
  addCircleMarkers(data = gaze_pv, radius = 2 , 
                   fillOpacity = 1, fillColor = "blue", 
                   popup = paste(gaze_pv$TYPE,": ",gaze_pv$NAMEPRI, as.character(gaze_pv$UPRN))  )
```


```{r}

gis_roof <- sf::st_read("./data/Applicable_roof_area.shp", quiet = TRUE) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)    
  st_transform(4326)    # convert CRS to wgs84 (from meter to degree) 

gis_roof_subset <- gis_roof[grid_sample,]


leaflet(width="80%") %>% 
  addProviderTiles(provider = providers$Esri.WorldImagery) %>% 
  #addTiles() %>% 
  addPolygons(data = gis_roof_subset , weight = 5, color = "red", fillColor = "red", fillOpacity = 0.5 ) %>% 
  addCircleMarkers(data = gaze_pv, radius = 5 , 
                   fillOpacity = 1, fillColor = "blue", 
                   popup = paste(gaze_pv$TYPE,": ",gaze_pv$NAMEPRI, as.character(gaze_pv$UPRN))  )


```

Patrick's comments: 
1) 3 of 10 sample randomly selected areas are industrial and have no PV at the moment
2) This result does not help the validation, and so no need to mention them
3) It is better to target residential areas and gain greater sample size 
4) Commercial buildings have larger roofs with higher PV potential, but their feasibility needs more rigorous assessment, so can be excluded from the scope of this work
5) New built houses have PV regardless of their feasibility, and they can also be eliminated from sample. 

# Re-select sample areas from residential areas, and eyeball existing PV. 

Grid for sample selection 

```{r}
leaflet(width="70%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addPolygons(data=soton_border, fillOpacity = 0, weight = 2, color = "blue") %>% 
  addPolygons(data = soton_grid_resize, fillOpacity = 0, 
              weight = 1, color="black") %>% 
  addScaleBar()
```

Use st_bbox function to find out the dimension of each cell 

```{r}

st_area(st_transform(soton_grid_resize[1,], 27700))
st_bbox(st_transform(soton_grid_resize[1,], 27700)) %>%
  as.numeric() %>% 
  unlist() %>% 
  matrix(nrow = 1, byrow = T) %>% 
  as.data.frame() %>% 
  setNames(c("xmin", "ymin", "xmax", "ymax")) %>% 
  mutate(x = xmax - xmin, y= ymax - ymin)
```


```{r}
# create a subset of gazetteer for residential properties only
# This is all properties (households) 
gaze_residential <- gaze %>% 
  #head()
  filter(str_detect(TYPE, "Residential"))


# Find out how many gazetteer points are in each grid cell 
soton_grid_residential <- soton_grid_resize %>%
  mutate(Grid_ID = seq.int(n())) %>% 
  st_join(gaze_residential, join = st_intersects) %>% # st_join creates a large number of pairs 
  filter(!is.na(POSTCODE)) %>%  # filter out empty joins. But this removes the cell entirely, instead of returning 0
  #head()
  group_by(Grid_ID) %>% 
  #summarise(Count_property = sum(!is.na(POSTCODE)) ) %>%  
  summarise(Count_property = n()) %>% 
  #head(10)
  ungroup 

```



## Preparation for Sample Selection
### histogram of property density across city

```{r}

# use distribution a histogram 
median_soton_grid_res <- median(soton_grid_residential$Count_property)
median_density <- round(median_soton_grid_res/67868*1000,1)

#min(soton_grid_residential$Count)

#library(scales)
ggplot(soton_grid_residential ) + 
  #geom_bar(aes(x=Count, y=..prop..) , stat = "count")+
  geom_histogram(aes(x=Count_property),stat = "bin" , bins = 30 , colour = "black")+
  geom_vline(xintercept = median_soton_grid_res, colour = "red")+
  geom_text(aes(x=median_soton_grid_res +150 , 
                y=130, label = paste("median:", median_soton_grid_res)  ) , 
            nudge_x = 10 , 
            color ="red" , 
            fontface='plain') + 
  labs(x = "Number of properties in each block" ,  
       y="Number of blocks" , 
       title = "Property density across city")+
  #scale_y_continuous(labels = function(x) paste(round(x,2 ), "%")) +
  scale_x_continuous( breaks = seq(0,1000, 100) )
  ylim(0,150)

```

### Map: distribution of property density

```{r}
# Show the distribution on map 
bins_property_density <- quantile(soton_grid_residential$Count_property, seq(from = 0.2, to =1, by=0.1))
pal_property_density <- colorBin("YlOrRd", domain = soton_grid_residential$Count_property, 
                bins = bins_property_density ,  na.color = "#ffffff00")

soton_grid_residential%>% 
  #filter(Count_property > 0) %>% 
  leaflet(width = "80%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addPolygons(data =  soton_border , weight = 2,
              fillOpacity = 0) %>% 
  addPolygons(fillColor = ~pal_property_density(Count_property), 
              weight = 1, color="black" , 
              fillOpacity = 1 , 
              label = ~as.character(Grid_ID)) %>% 
  addLegend("bottomright", 
            pal=pal_property_density, 
            values = ~Count_property, 
            title = "Property count" , 
            opacity = 1 , na.label = "empty") %>% 
  addScaleBar() 


```


```{r}
# The code below is to find out which seed would have Area No.13 included, 
# which is upper bassett, a residential area with large number of PV

allID <-soton_grid_residential %>% 
  filter(Count_property > 0 ) %>% 
  st_set_geometry(NULL) %>% 
  select(Grid_ID) 

allID

tempfuc <- function(x){
  set.seed(x)
  randid2 <- sample_n(allID, 10) %>% 
    mutate(Seed = x, Grid_ID = Grid_ID)
  return(randid2)
}

lapply(seq(1:100) , tempfuc) %>% 
  bind_rows() %>% 
  #head()
  filter(Grid_ID == 13) %>% 
  head()

```
## Sample selection

```{r}
set.seed(89) 
soton_grid_residential %>% 
  filter(Count_property > 0) %>% 
  #filter(Count_property >= quantile(soton_grid_residential$Count_property, 0.2) ) %>% 
  sample_n(10) %>% 
  leaflet(width = "70%") %>% 
  #addProviderTiles(providers$Esri.WorldImagery, options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addTiles() %>% 
  addPolygons(data = soton_border, color = "black", opacity = 1) %>% 
  addPolygons(data = soton_grid_residential, fillColor = ~pal_property_density(Count_property), 
              weight = 1, color="black" , 
              fillOpacity = 1 , 
              label = ~as.character(Grid_ID)) %>% 
  addPolygons(weight = 2, color = "blue", 
              opacity = 1  , fillOpacity = 0 , 
              label = ~paste("ID: ", Grid_ID), 
              labelOptions = labelOptions(noHide = T))

```






### Map: property density VS sample selection

```{r}

set.seed(89) 
soton_grid_residential %>% 
  filter(Count_property > 0) %>% 
  sample_n(10) ->soton_grid_sample


soton_grid_residential %>% 
  leaflet(width = "80%") %>% 
  addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addPolygons(data =  soton_border , weight = 2,
              fillOpacity = 0) %>% 
  addPolygons(fillColor = ~pal_property_density(Count_property), 
              weight = 0, color="black" , 
              fillOpacity = 1 , 
              label = ~as.character(Count_property)) %>% 
  addPolygons(data = soton_grid_resize, 
              fillOpacity = 0, 
              weight = 1, color = "black") %>% 
  addPolygons(data = soton_grid_sample, fillOpacity = 0, 
              color = "blue" , opacity = 1) %>% 
  addLegend("bottomright",  data = soton_grid_sample, colors = "blue", opacity = 0, labels = "Sample area" ) %>% 
  addLegend("bottomright", 
            pal=pal_property_density, 
            values = ~Count_property, 
            title = "Property count" , 
            opacity = 1) %>%   
  addScaleBar() 
```

For an unknown reason, the sample areas under Seed 89 show about 3 miss match areas, which are adjacent to intended areas, which have been visually examined. 

Therefore, the sample areas that will be used in future analysis, will be from a list shown below: 

13, 51, 134, 173, 502, 528, 585, 674, 692, 650 

```{r}
# randomly select 10 areas among those cells with at least 1 residential property
# use seed 89 as it includes Upper bassett where a large number of PV are found
#set.seed(89)
#grid_sample_residential <- soton_grid_residential %>% 
#  #filter(Count_property > 0) %>% 
#  sample_n(10) 

#head(grid_sample_residential,10)


Sample_grid <- soton_grid_residential %>% 
  filter(Grid_ID %in% c(13, 51, 134, 173, 502, 528, 585, 674, 692, 650 ))


# subset gazetteer data for only those in sample areas
Sample_gaze_residential <- gaze[Sample_grid,] %>% 
  filter(grepl("Residential" , TYPE))
```


```{r}
nrow(Sample_gaze)
```
```{r}
head(Sample_grid)

Sample_grid_1 <- Sample_grid %>% 
  select(Grid_ID) %>%
  st_join(Sample_gaze_residential, join=st_intersects) %>% 
  #head()
  #filter(grepl("Residential", TYPE)) %>% 
  #nrow()
  #head(10)
  group_by(Grid_ID) %>% 
  summarise(Count_gaze = n()) 
  #summarise(Count_gaze = sum(!is.na(POSTCODE))) %>% 
  #head(10)

```


## EXISTING PV

All the selected buildings were eyeballed using Google earth, and the results are imported backed to R.

```{r}
existingPV_soton <- sf::st_read("./data/existing_PV_in_southampton_10_sample_areas.kml" , quiet = TRUE) 

#st_write(grid_sample_residential , "./data/grid_sample_new.shp", layer_options = "GEOMETRY=AS_XY" )

```

### Map: existing PV

```{r}
# map showing all existing PVs together with the 10 sample areas
leaflet(width="80%") %>% 
  #addTiles(options = providerTileOptions(maxZoom = 12,minZoom= 12)) %>% 
  addTiles(options = providerTileOptions(maxZoom = 100)) %>% 
  addPolygons(data = Sample_grid, color = "red", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "red") %>% 
  #addPolygons(data = soton_grid_residential, color = "black", 
  #            fillOpacity = 0, opacity = 1, 
  #            popup = ~as.character(Grid_ID)) %>% 
  addCircleMarkers(data=existingPV_soton, radius = 1, fillOpacity = 1, stroke = 1, 
                   popup = ~ADDRESS )
```




### Number of existing PV in each cell 

Total number of properties in sample areas is 1554, of which 44 have installed PV, accounting to 2.8%. The distribution of these systems is not evenly distributed, geographically. 


```{r}

Sample_grid_PV <- Sample_grid_1 %>% 
  #head()
  st_join(existingPV_soton, join= st_intersects ) %>% 
  #head(100)
  group_by(Grid_ID) %>% 
  summarise(Count_PV = sum(!is.na(ADDRESS)) , Count_gaze=Count_gaze[1]) 



bin_PV <- c(0, 1  , 3 , 10,16)
pal_PV <- colorBin("YlOrRd", domain = Sample_grid_PV, right = F, 
                   bins = bin_PV, na.color = "#ffffff00")

pal_PV(Sample_grid_PV$Count_PV)

colorBin("YlOrRd", right = F, domain = NULL , 
                   bins = bin_PV, na.color = "#ffffff00")(Sample_grid_PV$Count_PV)

leaflet(data = Sample_grid_PV) %>% 
  addTiles(options =providerTileOptions(maxZoom = 12,minZoom= 12) ) %>% 
  #addTiles() %>% 
  addPolygons(data =  soton_border , weight = 2, color = "black",
              popup = ~CITY ,
              fillOpacity = 0) %>%   
  addPolygons(fillOpacity = 1, opacity = 1, 
              color = "black" , weight =1, 
              #fillColor = ~pal_PV(Count_PV), 
              fillColor = ~colorBin("YlOrRd", domain = NULL, bins = bin_PV)(Count_PV)  , 
              popup = ~as.character(Count_PV)) %>% 
  #addPolygons(data = sra_sample) %>% 
  addLegend("bottomright", 
            pal=colorBin("YlOrRd", domain = NULL, bins = bin_PV), 
            values = ~Count_PV, 
            title = "PV count" , 
            opacity = 1 , na.label = "empty") %>% 
  addScaleBar() 


  
```

To count the number of model identified buildings (in fact, properties) in each area, the sra is firstly combined with building polygons (again, property polygons)

```{r}
sra_10_10_600 <- sf::st_read("./data/SRA_10_10_600.shp", quiet = T) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700) 
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) 

Sample_property <- sf::st_read("./data/Area_building_grid.shp", quiet = T) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700)   
  st_transform(4326) %>%   # convert CRS to wgs84 (from meter to degree) 
  mutate(polygon_ID = seq.int(n()))
  
nrow(Sample_gaze_residential)
#Sample_property_w_PV <- 


```

Number of gazetteer: 1621
After combining the polygons with gazetteers, the number of polygons with points goes up to 1727

```{r}
nrow(Sample_property[Sample_gaze_residential,])

```

The next step is to find out gaze points that have more than one polygons

The duplicates are found to be from the original polygon layers. 

The function st_difference() is used to remove duplicated polygons. 

```{r}

Sample_property_dist <- Sample_property %>% 
  st_difference() %>%    # duplicates from original layers are removed 
  select(BID = polygon_ID) %>% 
  st_join(Sample_gaze_residential, join = st_intersects) %>% 
  group_by(BID) %>% 
  #head()
  summarise(Gaze_per_polygon = sum(!is.na(POSTCODE))) %>% 
  filter(Gaze_per_polygon > 0) 


Sample_gaze_residential %>%
  mutate(Gaze_ID = seq.int(n())) %>% 
  #head()
  #filter(Gaze_ID == 1) %>% 
  st_join(Sample_property_dist, join = st_intersects) %>% 
  #head()
  group_by(Gaze_ID) %>% 
  summarise(Count_polygon = sum(!is.na(polygon_ID)))

```



```{r}

Sample_property_sra_10_10_600 <-  Sample_property_dist %>% 
  st_join(Sample_sra, join = st_intersects) %>% 
  #nrow()
  filter(!is.na(OBJECTID)) %>% 
  #head()
  group_by(BID) %>% 
  #head()
  summarise( Count_sra = sum(!is.na(OBJECTID)) , Gaze_per_polygon  = Gaze_per_polygon [1] ) 
  #nrow()
  #arrange(desc(Count_sra)) %>% 
  #summary()
  #head()

head(Sample_grid_PV)
```


```{r}
head(Sample_property_sra_10_10_600)
head(sra_15_15_800_property)

Sample_grid_result_10_10_600 <- Sample_grid_PV %>% 
  #head() %>% 
  st_join(Sample_property_sra_10_10_600 , join = st_intersects) %>% 
  #head()  
  group_by(Grid_ID) %>% 
  summarise(Count_PV = Count_PV[1] , Count_gaze = Count_gaze[1] , 
            Count_est_PV = sum(!is.na(BID)), 
            Count_sra = sum(Count_sra)) %>% 
  mutate(sra_percent = Count_est_PV / Count_gaze) %>% 
  mutate(PV_uptake = Count_PV / Count_gaze) %>% 
  arrange(sra_percent) 

head(Sample_grid_result_10_10_600, 10)

```



```{r}
Sample_grid_result_10_10_600 %>% 
  ggplot()+ 
    geom_point(aes(x = sra_percent, y = PV_uptake))
```


```{r}

Sample_grid_result_10_10_600 %>% 
  leaflet(width = "80%") %>% 
  addTiles() %>% 
  addPolygons(weight = 0.5, color = "black", opacity = 1, 
              fillOpacity = 1,
              popup = ~paste("Actual PV installed:", as.character(Count_PV)), 
              fillColor = ~colorBin("YlOrRd" , domain = NULL, bins = seq(0, 1, 0.2) )(sra_percent)) %>%
  addLegend(position = "bottomright", 
            title = "Estimated potential" ,
            opacity = 1, 
            pal = colorBin("YlOrRd" , domain = NULL, bins = seq(0, 1, 0.2) ) , 
            values = ~sra_percent )

```


```{r}
rsq <- function(x, y) cor(x, y)^2

rsq(Sample_grid_result_10_10_600$sra_percent , Sample_grid_result$PV_uptake)
```

#1 Linear regression 

```{r}
model_ln <- lm(formula = PV_uptake ~ sra_percent, data = Sample_grid_result_10_10_600)

summary(model_ln)

```

Plot below shows the linear fitting result, which has an R squared value of 0.2 

A noticeable problem is the negative returns of estimated PV uptake, which should not be lower than zero. 

```{r}
predict_PV_uptake <- predict(model_ln, data.frame(sra_percent = seq(0,1,0.2)), se.fit = T) %>% 
  as.data.frame() %>% 
  select(est_PV_uptake = fit, se.fit) %>% 
  mutate(sra_percent = seq(0,1,0.2)) 

ggplot()+
  geom_line(data = predict_PV_uptake, aes(x=sra_percent, y=est_PV_uptake)) +
  geom_point(data = Sample_grid_result_10_10_600, aes(x=sra_percent, y = PV_uptake), colour = "red")+
  geom_text(aes(x=0.9, y= 0.1, label = "R seq = 0.21"))+
  labs(title = "Bassett included, R seq = 0.21")

```

Below attempting an non-linear regression, the linear regression is better trained by removing the outlier, Bassett which is the point in top right corner. 


```{r}
model_ln_2 <- Sample_grid_result_10_10_600 %>% 
  filter(PV_uptake < 0.1) %>% 
  lm(formula = PV_uptake ~ sra_percent)
  #head(10)

summary(model_ln_2)
```


```{r}
predict(model_ln_2, data.frame(sra_percent = seq(0,1,0.2)), se.fit = T) %>% 
  as.data.frame() %>% 
  select(est_PV_uptake = fit, se.fit) %>% 
  mutate(sra_percent = seq(0,1,0.2)) %>% 
  ggplot()+
    geom_line(aes(x=sra_percent, y=est_PV_uptake)) +
    geom_point(data = Sample_grid_result, aes(x=sra_percent, y = PV_uptake), colour = "red")+
    #geom_text(aes(x=0.9, y= 0.1, label = "R seq = 0.02"))+ 
    labs(title = "Bassett excluded, R seq = 0.02")
    
```


# Compare SRA 10-10-600 WITH SRA 10-10-800

```{r}
# Due to grid_sample IDs' mismatch problem, all SRA under 10-10-800 are imported to R
# then to use the [sample_grid, ] to subset SRAs in sample grids

sra_soton_10_10_800 <- sf::st_read("../GIS/Southampton/SRA_soton_15_15_800.shp", quiet = T) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700) 
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) %>% 

sra_10_10_800 <- sra_soton_10_10_800[Sample_property_dist , ]

leaflet(width = "80%", height = "800") %>% 
  addTiles(options = providerTileOptions(maxZoom = 100) ) %>% 
  addPolygons(data = Sample_property_dist , color = "black", 
              opacity = 1, weight = 1) %>% 
  addPolygons(data = sra_10_10_600 , color = "red" , 
              opacity = 1, weight = 1, fillOpacity = 1) %>% 
  addPolygons(data = sra_15_15_800_property , color = "blue" ,
              opacity = 1, weight = 1, fillOpacity = 1) %>% 
  addCircleMarkers( data = existingPV_soton, 
                    color = "yellow" , 
                    radius = 2, opacity = 1, fillOpacity = 1)

```

The result of SRA_10_10_800 is not satisfactory, and the reason is found to be from STD_aspect and STD_slope. The next attempt is to try SRA_15_15_800 

```{r}

sra_soton_15_15_800 <- sf::st_read("../GIS/Southampton/SRA_soton_15_15_800.shp", quiet = T) %>% 
  st_set_crs(27700) %>% # The original shp doesn't have crs, so define it as OSGB (27700) 
  st_transform(4326)  # convert CRS to wgs84 (from meter to degree) %>% 

sra_15_15_800_property <- sra_soton_15_15_800[Sample_property_dist , ] %>% 
  mutate(BID = seq.int(n()))

leaflet(width = "80%", height = "800") %>% 
  #addTiles(options = providerTileOptions(maxZoom = 100) ) %>% 
  addProviderTiles(providers$Esri.WorldImagery , options = providerTileOptions(maxZoom = 100)) %>% 
  addPolygons(data = Sample_property_dist , color = "black", 
              opacity = 1, weight = 1) %>% 
  addPolygons(data = sra_10_10_600 , color = "red" , 
              opacity = 1, weight = 1, fillOpacity = 1) %>% 
  addPolygons(data = sra_15_15_800 , color = "blue" ,
              opacity = 1, weight = 1, fillOpacity = 1) %>% 
  addCircleMarkers( data = existingPV_soton, 
                    color = "yellow" , 
                    radius = 2, opacity = 1, fillOpacity = 1)


```

To find out how many polygons that have existing pv but not picked up by the model, and why. 

```{r}
install.packages("lwgeom ")
sf::st_area(Sample_property_dist)
# Layer to use is Sample_property_dist (where "dist" means distinct after de-duplication)
Sample_property_dist %>% 
  .[existingPV_soton, ] %>% 
  .[!lengths(st_intersects(., sra_15_15_800_property)), ] %>% 
  #st_length()
  #head()
  #nrow()
  leaflet(width = "70%") %>% 
    addTiles(options =  tileOptions(maxZoom = 100)) %>% 
    #addProviderTiles(providers$Esri.WorldImagery , options = tileOptions(maxZoom = 100)) %>% 
    #addProviderTiles(providers$Esri.WorldGrayCanvas) %>% 
    addPolygons(color = "red", weight = 10, opacity = 1, fillOpacity = 0, fillColor = "black")

```

1. To aggregate results into sample grid
2. find out proportion of buildings suitable for pv
3. find out proportion of suitable building across whole city

```{r}
# grid: Sample_grid_PV
head(Sample_grid_PV)

Sample_property_dist[sra_soton_15_15_800, ] 

Sample_grid_result_15_15_800 <- Sample_grid_PV %>% 
  #head() %>% 
  st_join(Sample_property_dist[sra_soton_15_15_800, ]  , join = st_intersects) %>% 
  #head()  
  group_by(Grid_ID) %>% 
  summarise(Count_PV = Count_PV[1] , Count_gaze = Count_gaze[1] , 
            Count_est_PV = sum(!is.na(BID))) %>% 
  mutate(sra_p = Count_est_PV / Count_gaze) %>% 
  mutate(PV_p = Count_PV / Count_gaze) %>% 
  mutate(sra_percent = percent(Count_est_PV / Count_gaze)) %>% 
  mutate(PV_percent = percent(Count_PV / Count_gaze)) %>% 
  arrange(sra_percent) 

head(Sample_grid_result_15_15_800, 10)
```

```{r}
Sample_grid_result_15_15_800 <- Sample_grid_result_15_15_800 %>% 
  arrange(Grid_ID) %>% 
  mutate(Count_PV = c(13,1,4,0,4,2,0,16,0,2)) %>% 
  mutate(PV_p = Count_PV / Count_gaze , 
         PV_percent = percent(PV_p)) 


```




To show a map with actual PV count

```{r}
temp <- st_set_geometry(Sample_grid_result_15_15_800 , NULL)

label_15_15_800 <- lapply(seq(10), function(i){
  paste0("#",  temp[i, "Grid_ID"] , "</p>" ,
         temp[i, "Count_PV"] , 
         "(", temp[i, "PV_uptake"] , ")" 
  )
})


Sample_grid_result_15_15_800[1, "Grid_ID"]
label_15_15_800



Sample_grid_result_15_15_800 %>% 
  #head()
  leaflet(width="500px",
          options = leafletOptions(zoomControl = FALSE) ) %>% 
  #addTiles(options = tileOptions(opacity = 1)) %>% 
  addProviderTiles(providers$Esri.WorldGrayCanvas) %>% 
  addPolygons(data = soton_border , color = "black" , weight = 0.5, 
              label = "Southampton", 
              labelOptions = labelOptions(noHide = T, 
                                          textOnly = T, 
                                          textsize = "14px", 
                                          direction = "center"), 
              fillColor = "blue" , fillOpacity = 0.0) %>% 
  addPolygons(fillOpacity = 1, weight = 1, color = "black" ,
              #label = lapply(label_15_15_800, HTML) ,
              label = ~paste0("#", as.character(Grid_ID), ": ", 
                              as.character(Count_PV) , 
                              " (",as.character(PV_percent), ")", 
                              sep = "") , 
              labelOptions = labelOptions(noHide = T, 
                                          textOnly = T, 
                                          textsize = "10px", 
                                          opacity = 1, 
                                          offset = c(40,-12),
                                          direction = "left" , 
                                          style = list("color" = "black")),
              fillColor = ~colorBin("YlOrRd", domain = NULL, bins = c(0, 1, 4, 10, 17))(Count_PV)) %>%
  addLegend(position = "bottomleft", 
            #title = "Number of PV</br>(proportion)" ,
            #pal = colorBin("YlOrRd" , domain = NULL, bins = c(0, 1, 4, 10, 17) ) , 
            #values = ~sra_percent, 
            colors = c("#FFFFB2", "#FECC5C", "#FD8D3C", "#E31A1C") ,
            labels = c("0" , "1 - 2" , "3 - 5" , ">10") ,
            title = "Number</br> (proportion)",
            opacity = 1 ) %>% 
  addScaleBar() #%>%

#  mapshot(file ="./actual_pv_map.png")


autoColour(c(0,1,2,3,4), c(0,1,2,3,4))
```

```{r}
Sample_grid_result_15_15_800 %>% 
  head(10) %>%
  mutate(sra_rank = ntile(Count_est_PV, 4)) %>% 
  arrange(sra_rank)
  summary
```

```{r}
Sample_grid_result_15_15_800 %>% 
  summary()
```

bins to set up for est_PV (n=4): <100, 100-125, 125-200, >200
bins for sra_p (n=4): 30%, 60-70%, 70-90% , >90%

```{r}
autoColour <- function(dataset = dataset, bins = bins){
  colorBin(palette = "YlOrRd", domain = NULL, bins = bins , na.color = "#aaff56")(dataset)
}
autoColour(c(1,2,3,4), c(1,2,3,4))

Sample_grid_result_15_15_800 %>%
  mutate(sra_rank = percentile(sra_p)) %>% 
  #head()
  #mutate(sra_rank = ntile(sra_p, 3)) %>% 
  #head(10) %>% 
  #select(sra_p) %>% 
  #mutate(sra_rank = percentile(sra_p)) %>% 
  #mutate(color = autoColour(sra_rank ,bins = seq(0,100,100/3))) %>% 
  #head(10)
  leaflet(width="500px",
          options = leafletOptions(zoomControl = FALSE) ) %>% 
    #addTiles() %>% 
    addProviderTiles(providers$Esri.WorldGrayCanvas) %>% 
    addPolygons(data = soton_border , color = "black" , weight = 1, 
              label = "Southampton", 
              labelOptions = labelOptions(noHide = T, 
                                          textOnly = T, 
                                          textsize = "14px", 
                                          direction = "center"), 
              opacity = 0.3, 
              fillColor = "blue" , fillOpacity = 0.0) %>% 
    addPolygons(fillOpacity = 1, weight = 1, color = "grey", opacity = 1,
                label = ~paste0("#", as.character(Grid_ID), ": ", 
                              as.character(sra_percent) , 
                              "(", as.character(Count_est_PV) ,")",
                              sep = "") , 
                labelOptions = labelOptions(noHide = T, 
                                            textOnly = T, 
                                            textsize = "10px", 
                                            opacity = 1, 
                                            offset = c(40,-12),
                                            direction = "left" , 
                                            style = list("color" = "black")),
                fillColor = ~autoColour(sra_p , bins = c(0,0.3,0.7,0.9,1))) %>% 
    addLegend( position = "bottomleft", 
               colors = c("#FFFFB2", "#FECC5C" ,"#FD8D3C", "#E31A1C"), 
               labels = c("<30%","60-70%","70-90%" , ">90%") , 
               title = "Propertion</br> (number)",
               opacity = 1) %>% 
    addScaleBar() 


```



```{r}
Sample_grid_result_15_15_800 %>% 
  head(10)
```


```{r}

```


























```{r}
autoColour <- function(dataset = dataset, bins = bins){
  colorBin(palette = "YlOrRd", domain = NULL, bins = bins , na.color = "#aaff56")(dataset)
}

unique(autoColour(seq(0:100), seq(0,100,100/3)))

Sample_grid_result_15_15_800 %>%
  mutate(sra_rank = percentile(sra_p)) %>% 
  #head()
  #mutate(sra_rank = ntile(sra_p, 3)) %>% 
  #head(10) %>% 
  #select(sra_p) %>% 
  #mutate(sra_rank = percentile(sra_p)) %>% 
  #mutate(color = autoColour(sra_rank ,bins = seq(0,100,100/3))) %>% 
  #head(10)
  leaflet() %>% 
    #addTiles() %>% 
    addProviderTiles(providers$Esri.WorldGrayCanvas) %>% 
    addPolygons(data = soton_border , color = "black" , weight = 1, 
              label = "Southampton", 
              labelOptions = labelOptions(noHide = T, 
                                          textOnly = T, 
                                          textsize = "14px", 
                                          direction = "center"), 
              fillColor = "blue" , fillOpacity = 0.0) %>% 
    addPolygons(fillOpacity = 1, weight = 1, color = "grey", opacity = 1,
                label = ~paste0("#", as.character(Grid_ID), ": ", 
                              as.character(sra_percent) , 
                              sep = "") , 
                labelOptions = labelOptions(noHide = T, 
                                            textOnly = T, 
                                            textsize = "10px", 
                                            opacity = 1, 
                                            offset = c(30,-12),
                                            direction = "left" , 
                                            style = list("color" = "black")),
                fillColor = ~autoColour(sra_rank , bins = seq(0,100,100/3))) %>% 
    addLegend( #title = "Estimated proportion of</br> properties suitable for PV",
               position = "bottomright", 
               colors = c("#FFEDA0", "#FEB24C", "#F03B20"), 
               labels = c("0-70%","70-85%","85-100%") , 
               opacity = 1) %>% 
    addScaleBar()


temp <- Sample_grid_result_15_15_800 %>% 
  mutate(sra_rank = percentile(sra_p)) %>% 
  head()
  
unique(autoColour(temp$sra_rank , bins = c(0, 33, 66, 100)) )


```


```{r}
model_ln_15_15_800 <- Sample_grid_result_15_15_800 %>% 
  #filter(PV_uptake < 0.1) %>% 
  lm(formula = PV_uptake ~ sra_percent)
  #head(10)

summary(model_ln_15_15_800)


predict_PV_uptake <- predict(model_ln_15_15_800, data.frame(sra_percent = seq(0,1,0.2)), se.fit = T) %>% 
  as.data.frame() %>% 
  select(est_PV_uptake = fit, se.fit) %>% 
  mutate(sra_percent = seq(0,1,0.2)) 

ggplot()+
  geom_line(data = predict_PV_uptake, aes(x=sra_percent, y=est_PV_uptake)) +
  geom_point(data = Sample_grid_result_15_15_800, 
             aes(x=sra_percent, y = PV_uptake, 
                 colour = factor(Count_PV) ) ) +
  scale_colour_manual(values = rev(brewer.pal(7, "RdYlGn")))+
  #scale_color_brewer(  palette = "RdYlGn")+
  geom_text(aes(x=0.9, y= 0.1, label = "R seq = 0.189")) +
  scale_y_continuous(limits = c(0,0.2))+
  labs(title = "Bassett included, R seq = 0.189" , colour="Number of existing PV")

head(Sample_grid_result_15_15_800, 10)

```



```{r}

st_intersects(Sample_property_dist, existingPV_soton) %>% 
  lengths()

lengths(Sample_property_dist)


existingPV_soton %>% 
  head()
```


```{r}
existingPV_soton %>% 
  st_join(Sample_property_dist, join=st_intersects) %>% 
  filter(is.na(BID)) %>% 
  head()
  leaflet() %>%  
    addTiles() %>% 
    addCircleMarkers()
  #head()
  nrow()
```

2 existing PV systems will need to be removed due to (1) it's outside any building polygon as the building sits on the border of the area - Land Adj To 35, and (2) it's found to be a duplica to another PV point in the same polygon - 45A SO19 5LQ. 

```{r}

polygon_error <- Sample_property_dist %>% 
  #nrow()
  st_join(existingPV_soton, join=st_intersects) %>%  
  group_by(BID) %>%  
  #head()
  summarise(countPV = sum(!is.na(ADDRESS0))) %>% 
  filter(countPV>1) 
  
existingPV_soton %>% 
  .[polygon_error, ] %>% 
  head()
  leaflet(options = providerTileOptions(maxZoom = 100) ) %>% 
    addTiles() %>% 
    addCircleMarkers()
    #addPolygons(color = "red", weight = 100) %>% 
    #addCircleMarkers(data=existingPV_soton , radius = 1)
  

existingPV_soton_n <-  existingPV_soton %>% 
  filter(!(NAMEPRI == "45A" & POSTCODE =="SO19 5LQ") & NAMEPRI != "Land Adj To 35") 

```

The model validation is to (1) see how many of the existing PV are correctly detected; (2) where are they based; (3) error analysis; (4) see if I can do a negative detection - to separate buildings into "good" and "bad" groups. 

## 1. aggregate the number of pv and number of correct matches into areas 

```{r}

Sample_property_results <- Sample_property_dist %>% 
  .[existingPV_soton_n, ] %>% 
  #head()
  st_join(sra_15_15_800, join=st_intersects) %>% 
  #head()
  group_by(BID) %>% 
  summarise(count_model = sum(!is.na(Id)), Gaze_per_polygon = Gaze_per_polygon [1]) 

Sample_grid %>%  
  st_join(Sample_property_results, join = st_intersects) %>%  
  group_by(Grid_ID) %>% 
  summarise(Property_n = Count_property[1], 
            Model_n = sum(count_model>0), 
            PV_n = sum(!is.na(Gaze_per_polygon)) ) %>% 
  head(10) %>% 
  write.csv("./grid_summary.csv")
```


```{r}
DT <- data.table(A=1:10, B=c(0.01, 0.04, 0.06, 0.09, 0.1, 0.13, 0.14, 0.15, 0.17, 0.71)) 

DT %>% 
  group_by(gr = cut(B, breaks = seq(0, 1, by=0.1))) %>% 
  head(10)
```


```{r}
myFun <- function(n = 5000) {
  a <- do.call(paste0, replicate(5, sample(LETTERS, n, TRUE), FALSE))
  paste0(a, sprintf("%04d", sample(9999, n, TRUE)), sample(LETTERS, n, TRUE))
}

set.seed(5013)
myFun(14) %>% 
  as.data.frame() %>% 
  setnames("d") %>% 
  mutate(No = seq.int(n()) , Password = d)
```

Compare radiation on two buildings in Bassett. The difference is caused by shading

```{r}
bassett_dir <- "./data/"
bassett_sample_list <- intersect(list.files(bassett_dir, pattern = "Month"), list.files(bassett_dir, pattern =".dbf"))
install.packages("foreign")


read.dbf(bassett_sample_list[1])
for (file in bassett_sample_list){
  
  
}

```


























